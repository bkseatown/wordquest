#!/usr/bin/env python3
"""
generate_words_inline.py ‚Äî Word Quest
=======================================
Converts app_ready_database_FINAL.json (or the _with_audio version)
into data/words-inline.js so the game loads without a JSON fetch.

This fixes the "words-inline.js not found" error when running locally.

Run from anywhere:
  python3 generate_words_inline.py \
    --json /Users/robertwilliamknaus/Desktop/WordQuest/3_App_Build/app_ready_database_FINAL.json \
    --out  /Users/robertwilliamknaus/Desktop/WordQuest/data/words-inline.js

Or use the _with_audio version if you've already run add_audio_paths.py:
  python3 generate_words_inline.py \
    --json /Users/robertwilliamknaus/Desktop/WordQuest/3_App_Build/app_ready_database_with_audio.json \
    --out  /Users/robertwilliamknaus/Desktop/WordQuest/data/words-inline.js
"""

import json, sys, argparse
from pathlib import Path

def normalize_entry(word, v):
    """Convert any known JSON format to the unified WQ_WORD_DATA shape."""
    w = word.lower().strip()

    # Already in new format?
    if "content" in v:
        return (w, v)

    # Old WORD_ENTRIES format ‚Äî convert to new shape
    en = v.get("en") or {}
    return (w, {
        "display_word": w,
        "game_tag":     v.get("game_tag", "playable"),
        "metadata": {
            "grade_band":  v.get("grade_band", ""),
            "tier":        v.get("tier", ""),
            "syllables":   v.get("syllable_count", 1),
        },
        "content": {
            "definition":  en.get("def") or v.get("definition") or v.get("def") or "",
            "sentence":    en.get("sentence") or v.get("sentence") or "",
            "fun_add_on":  en.get("fun") or v.get("fun_add_on") or v.get("fun") or "",
        },
        "instructional_paths": {
            "phonics": (v.get("phonics") or {}).get("patterns", [None])[0],
        },
        "audio_paths": {
            "word_audio":        (v.get("audio") or {}).get("word"),
            "definition_audio":  (v.get("audio") or {}).get("def"),
            "sentence_audio":    (v.get("audio") or {}).get("sentence"),
            "fun_audio":         (v.get("audio") or {}).get("fun"),
        }
    })

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--json", required=True, help="Path to JSON database")
    ap.add_argument("--out",  required=True, help="Output path for words-inline.js")
    args = ap.parse_args()

    json_path = Path(args.json)
    out_path  = Path(args.out)

    if not json_path.exists():
        print(f"‚ùå JSON not found: {json_path}"); sys.exit(1)

    out_path.parent.mkdir(parents=True, exist_ok=True)

    print(f"üìÇ Reading: {json_path}")
    with open(json_path, encoding="utf-8") as f:
        raw = json.load(f)

    # Handle list or dict
    if isinstance(raw, list):
        items = {(e.get("word") or e.get("display_word", "")).lower(): e for e in raw if e.get("word") or e.get("display_word")}
    else:
        items = raw

    # Normalize all entries
    normalized = {}
    skipped = 0
    for key, val in items.items():
        word_key = (val.get("display_word") or val.get("word") or key or "").lower().strip()
        if not word_key:
            skipped += 1
            continue
        _, entry = normalize_entry(word_key, val)
        normalized[word_key] = entry

    playable = sum(1 for e in normalized.values() if e.get("game_tag") == "playable")

    print(f"‚úÖ {len(normalized)} entries ({playable} playable, {skipped} skipped)")

    js_content = f"""// words-inline.js ‚Äî Word Quest
// Auto-generated by generate_words_inline.py
// {len(normalized)} words | {playable} playable
// Do not edit manually ‚Äî regenerate from the JSON database.

window.WQ_WORD_DATA = {json.dumps(normalized, ensure_ascii=False, indent=2)};
"""

    with open(out_path, "w", encoding="utf-8") as f:
        f.write(js_content)

    size_mb = out_path.stat().st_size / 1_000_000
    print(f"üì¶ Written: {out_path}  ({size_mb:.1f} MB)")
    print(f"\n‚úÖ Done! Refresh http://localhost:8000 to see words load.")

if __name__ == "__main__":
    main()
